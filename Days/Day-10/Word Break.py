# https://leetcode.com/problems/word-break-ii/

# Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word.Return all such possible sentences in any order.
# Note that the same word in the dictionary may be reused multiple times in the segmentation.

# Example1:
# Input: s = "catsanddog", wordDict = ["cat", "cats", "and", "sand", "dog"]
# Output: ["cats and dog", "cat sand dog"]

# Example 2:
# Input: s = "pineapplepenapple", wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
# Output: ["pine apple pen apple", "pineapple pen apple", "pine applepen apple"]
# Explanation: Note that you are allowed to reuse a dictionary word.

# Example3:
# Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
# Output: []

# Constraints:
# 1 <= s.length <= 20
# 1 <= wordDict.length <= 1000
# 1 <= wordDict[i].length <= 10s and wordDict[i] consist of only lowercase English letters. All the strings of wordDict are unique. Input is generated in a way that the length of the answer doesn't exceed 105.
# ---------------------------------------------------------------------------------------------------------------------------------------
# Approach1: Traverse entire given string starting from index- 0. For every traversal check if from starting i.e.0 if uptill here the subString formed is included in wordDict. If so, we maintain a currSentence Arr which gets appended with this subString. Further to traverse the farther part of string with chosen subString as an option, we make a recursive call with updated starting from index- current-iteration's-pointer + 1 and updated currSentence. In doing this if in helperFunc we find starting equal to length of string then that will mean we've been able to deligate the entire given string into words found in wordDict only that's how we are now at a startingPoint==len(givenString) so we append a string formed by connect items of currSentence with a space. Line after recursive calls would be responsible to remove the last appended word from currSentence so in that continuation of iterations, other words could be found and thus all possibilities of string Traversal is explored.
from typing import List


class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        ans = []

        def helperfunc(n, currSentence):
            if n == len(s): ans.append(' '.join(currSentence))
            for i in range(n, len(s)):
                if s[n:i + 1] in wordDict:
                    currSentence.append(s[n:i + 1])
                    helperfunc(i + 1, currSentence)
                    currSentence.pop()

        helperfunc(0, [])
        return ans


S = Solution()
print(S.wordBreak("catsanddog", ["cat", "cats", "and", "sand", "dog"]))  # O/P:["cats and dog","cat sand dog"]
# TC: O((2^n)k)given n is size of given String and k is size of wordDict. Explanation: 2^n for all recursive calls generated by for loop- as for a given string of lenght n, 2^n substrings could be formed. Further within each call, we are checking for a string to be present in wordDict, which will take k time given k is number of items in wordDict
# SC: O(n+k) given n is size of given String and k is size of wordDict. Explanation: Recursive stack space- n. Plus, currSentence can at max have all words in wordDict, adding a k more space.