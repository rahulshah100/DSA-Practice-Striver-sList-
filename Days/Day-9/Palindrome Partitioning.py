# https://leetcode.com/problems/palindrome-partitioning/

# Given a strings, partition s such that every substring of the partition is a palindrome .Return all possible palindrome partitioning of s.

# Example1:
# Input: s = "aab"
# Output: [["a", "a", "b"], ["aa", "b"]]

# Example 2:
# Input: s = "a"
# Output: [["a"]]

# Constraints:
# 1 <= s.length <= 16
# s contains only lowercase English letters.
# ------------------------------------------------------------------------------------------------------------------------------------------------
# We will traverse the given string and if uptill any point of iteration, we find string to be palindrome i.e. string[:i+1] is palindrome then we keep this much stored in a subArr and pass the next index i.e. i+1 and this subArr to next recursive call where starting from this index i.e.i+1 uptill length of given string further iteration will happend and palindrome if found then it is again recursive called upon the i+1 and updated subArr. In doing this when index-param is found equal to length of given string we append the subArr in a resArr and return out of recursion. There is an unwritten base case too where index==len(given-string) is not met but for loop's iteration gets over. That's where we can say although sub-string/str uptill the index-param has been palindrome but string to the right from index is not palindrome and hence this way of partition wont yield every substring of given string as palindrome. Therefore this wont be considered for answer. Following recursive tree better demonstrates this recursion:
#                                                               aabb
#                                                   a|abb                aa|bb     Starting from left most a, we find a and aa as left strings uptill which palindrome is forming
#                                           a|a|bb               Starting from 2nd 'a' in a|abb we find 'a' itself a palindrome but after that ab or abb are not. Same with aa|bb
#     a|a|b|b    a|a|bb|     Starting from 1st 'b' in a|a|bb we find 'b' to be palindrome & 'bb' to be another one too. At this stage for a|a|bb| index=len & so it is appneded in resArr
#     a|a|b|b|        Starting from 2nd 'b' we find that to be a palindrome in itself and further index=len(given string) so this becomes another answer.
from typing import List


class Solution:
    def partition(self, s: str) -> List[List[str]]:
        resArr = []

        def helper(index, subArr):
            if index == len(s):
                resArr.append(subArr)
                return

            for i in range(index, len(s)):
                if palindrome(s[index:i + 1]):
                    helper(i + 1, subArr + [s[index:i + 1]])

        helper(0, [])
        return resArr


def palindrome(str):
    start, end = 0, len(str) - 1
    while start < end:
        if str[start] != str[end]:
            return False
        start, end = start + 1, end - 1
    return True


S = Solution()
print(S.partition("aab"))  # O/P: [["a","a","b"],["aa","b"]]
# TC: O(2n(2^n)) Explanation: 2^n for all recursive calls generated by for loop- as for a given string of lenght n, 2^n substrings could be formed. n for running checking/running palindrome function and an additionaly n for concatinating subArr is palindrome is valid, together building- 2n. As running palindrome and concatinating will occur for all substrings in worst case so it'll multiply with 2^n.
# SC: O(n) Explanation: at max recursion depth would be of n, showing the recursive stack space.
