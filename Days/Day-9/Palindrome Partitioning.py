# https://leetcode.com/problems/palindrome-partitioning/

# Given a strings, partition s such that every substring of the partition is a palindrome .Return all possible palindrome partitioning of s.

# Example1:
# Input: s = "aab"
# Output: [["a", "a", "b"], ["aa", "b"]]

# Example 2:
# Input: s = "a"
# Output: [["a"]]

# Constraints:
# 1 <= s.length <= 16
# s contains only lowercase English letters.
# ------------------------------------------------------------------------------------------------------------------------------------------------
# We will traverse the given string and if uptill any point of iteration, we find string to be palindrome i.e. string[:i+1] is palindrome then we keep this much stored in a temp and pass the next index i.e. i+1 and this temp to next recursive call where starting from this index i.e.i+1 uptill length of given string further iteration will happen and palindrome if found then it is again recursive called upon the i+1 and updated temp. In doing this when index-param is found equal to length of given string we append the temp in a ansArr and return out of recursion. There is an unwritten base case too where index==len(given-string) is not met but for loop's iteration gets over. That's where we can say although sub-string/str uptill the index-param has been palindrome but string to the right from index is not palindrome and hence this way of partition won't yield every substring of given string as palindrome. Therefore, this won't be considered for answer. Following recursive tree better demonstrates this recursion:
#                                                               aabb
#                                                   a|abb                aa|bb     Starting from left most a, we find a and aa as left strings uptill which palindrome is forming
#                                           a|a|bb               Starting from 2nd 'a' in a|abb we find 'a' itself a palindrome but after that ab or abb are not. Same with aa|bb
#                                   a|a|b|b    a|a|bb|     Starting from 1st 'b' in a|a|bb we find 'b' to be palindrome & 'bb' to be another one too. At this stage for a|a|bb| index=len & so it is appended in ansArr
#                                   a|a|b|b|        Starting from 2nd 'b' we find that to be a palindrome in itself and further index=len(given string) so this becomes another answer.
from typing import List

class Solution:
    def partition(self, s: str) -> List[List[str]]:
        return self.helperfunc(0, [], [], s)

    def helperfunc(self, index, temp, ansArr, s):
        if index == len(s):
            ansArr.append(temp[:])

        for i in range(index, len(s)):
            if self.palindrome(s[index:i + 1]):
                temp.append(s[index:i + 1])
                self.helperfunc(i + 1, temp, ansArr, s)
                temp.pop()
        return ansArr

    def palindrome(self, string):
        i, j = 0, len(string) - 1
        while i <= j:
            if string[i] != string[j]:
                return False
            i += 1
            j -= 1
        return True

S = Solution()
print(S.partition("aab"))
# TC: O(2n(2^n)) Explanation: 2^n for all recursive calls generated by for loop - as for a given string of length n, 2^n substrings could be formed. n for running palindrome function, and an additional n for copying temp in ansArr (this last complexity of creating a shallow copy we have kept avoiding this far for generalising purposes of Tc, and to keep TC simple but in reality it does somewhat adds to the time) which in worst case will happen for each time in 2^n substrings.
# SC: O(2n) Explanation: at max recursion depth would be of n, showing the recursive stack space and temp could be holding n items.
