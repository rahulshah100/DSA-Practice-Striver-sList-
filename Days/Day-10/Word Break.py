# https://leetcode.com/problems/word-break-ii/

# Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word.Return all such possible sentences in any order.
# Note that the same word in the dictionary may be reused multiple times in the segmentation.

# Example1:
# Input: s = "catsanddog", wordDict = ["cat", "cats", "and", "sand", "dog"]
# Output: ["cats and dog", "cat sand dog"]

# Example 2:
# Input: s = "pineapplepenapple", wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
# Output: ["pine apple pen apple", "pineapple pen apple", "pine applepen apple"]
# Explanation: Note that you are allowed to reuse a dictionary word.

# Example3:
# Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
# Output: []

# Constraints:
# 1 <= s.length <= 20
# 1 <= wordDict.length <= 1000
# 1 <= wordDict[i].length <= 10s and wordDict[i] consist of only lowercase English letters. All the strings of wordDict are unique. Input is generated in a way that the length of the answer doesn't exceed 105.
# ---------------------------------------------------------------------------------------------------------------------------------------
# Approach1: While traversing the given string from startingIndex 0 up-to the whole length, as we encounter the portion of string from startingIndex to i, we'll make a recursive call to the same function while maintaining a temp array in which startingIndex to i is stored as a word and passed into this new call, with an startingIndex of i now. Also as there could be further possibility where we don't consider the found word for once, thinking we can find a longer word and so in backtracking we pop the temp and let the iteration of for-loop continue. In function call base condition is where startingIndex is length of the given string where we append temp into ansArr.
from typing import List

class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        return self.helperfunc(0, [], [], s, wordDict)

    def helperfunc(self, index, temp, ansArr, s, wordDict):
        if index==len(s):
            ansArr.append(' '.join(temp[:]))
            return

        for i in range(index, len(s)+1):
            if s[index:i] in wordDict:
                temp.append(s[index:i])
                self.helperfunc(i, temp, ansArr, s, wordDict)
                temp.pop()

        return ansArr

s = "catsanddog"
w = ["cat", "cats", "and", "sand", "dog"]
S = Solution()
print(S.wordBreak(s, w))  # O/P: ["cats and dog","cat sand dog"]

# TC: O((2^n)k)given n is size of given String and k is size of wordDict. Explanation: 2^n for all recursive calls generated by for loop- as for a given string of lenght n, 2^n substrings could be formed. Further, within each call, we are checking for a string to be present in wordDict, which will take k time given k is number of items in wordDict
# SC: O(n+k) given n is size of given String and k is size of wordDict. Explanation: Recursive stack space- n. Plus, currSentence can at max have all words in wordDict, adding a k more space.